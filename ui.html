<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
      window.onload = function () {
        if (!window.JSZip || !window.FileSaver) {
          console.error("JSZip or FileSaver failed to load");
          document.getElementById("download-all-web").disabled = true;
          document.getElementById("download-all-web").title =
            "Download all feature unavailable";
        } else {
          console.log("JSZip and FileSaver loaded successfully");
        }
      };
    </script>
    <style>
      body {
        font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI",
          Roboto, sans-serif;
        margin: 0;
        padding: 20px;
      }
      input {
        width: 100%;
        padding: 8px;
        margin-bottom: 12px;
        border: 1px solid #d1d5db;
        border-radius: 4px;
        box-sizing: border-box;
      }
      input:focus {
        border: 1px solid transparent;
        outline: 1px solid #ff0266;
      }
      button {
        background: #ff0266;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
        margin-bottom: 8px;
      }
      button:disabled {
        background: #d1d5db;
        color: #1f2937;
        cursor: not-allowed;
      }
      button.secondary {
        background: #f9fafb;
        color: #ff0266;
        border: 1px solid #ff0266;
      }
      .error,
      .success,
      .info {
        font-size: 12px;
      }
      .error {
        color: #db2b3a;
        margin-top: 8px;
      }
      .success {
        color: #568177;
        margin-top: 8px;
      }
      .info {
        color: #568177;
        margin-top: 8px;
      }
      .info a {
        color: #568177;
        text-decoration: underline;
      }
      #download-section {
        display: none;
        margin-top: 20px;
        padding-top: 20px;
        border-top: 1px solid #eee;
      }
    </style>
  </head>
  <body>
    <div id="form-section">
      <input
        type="text"
        id="whiteLabelName"
        placeholder="Enter white label name (e.g., ChainelsWhiteLabel)"
        value="ChainelsWhiteLabel"
      />
      <input type="file" id="favicon" accept="image/*" />
      <button id="generate">Generate Theme Files</button>
    </div>

    <div id="download-section">
      <h3>Generated Files</h3>
      <button id="download-all-web" class="secondary">
        Download All Files
      </button>
      <div style="margin: 16px 0; border-top: 1px solid #eee"></div>
      <button id="download-ts" class="secondary">Download TypeScript</button>
      <button id="download-scss-colors" class="secondary">
        Download Colors SCSS
      </button>
      <button id="download-scss-theme" class="secondary">
        Download Theme SCSS
      </button>
      <button id="download-scss-email" class="secondary">
        Download Email SCSS
      </button>
      <button id="download-favicons" class="secondary">
        Download Favicons
      </button>
      <button id="download-app-config" class="secondary">
        Download App Config
      </button>
      <div style="margin: 16px 0; border-top: 1px solid #eee"></div>
      <div id="pr-form">
        <h3>Create Pull Requests</h3>
        <input
          type="text"
          id="bitbucket-username"
          placeholder="Bitbucket Username"
          value="guidochainels"
          required
        />
        <input
          type="password"
          id="bitbucket-token"
          placeholder="Bitbucket App Password"
          required
        />
        <div style="font-size: 12px; margin-bottom: 12px; color: #666">
          Create an app password with these permissions:
          <ul style="margin: 8px 0; padding-left: 20px">
            <li>Repository: Read, Write</li>
            <li>Pull requests: Read, Write</li>
          </ul>
          <a
            href="https://bitbucket.org/account/settings/app-passwords/"
            target="_blank"
            >Create App Password</a
          >
        </div>
        <button id="submit-prs" class="secondary">Create Pull Requests</button>
      </div>
    </div>

    <div id="message"></div>

    <script>
      let generatedFiles = null;
      let favicon = null;
      let generatedFaviconFiles = null;

      // Comprehensive favicon sizes matching RealFaviconGenerator output
      const faviconSizes = [
        // Standard favicons
        { width: 16, height: 16, name: "favicon-16x16.png" },
        { width: 32, height: 32, name: "favicon-32x32.png" },
        // Apple Touch Icons
        { width: 57, height: 57, name: "apple-touch-icon.png" },
        { width: 60, height: 60, name: "apple-touch-icon-60x60.png" },
        { width: 72, height: 72, name: "apple-touch-icon-72x72.png" },
        { width: 76, height: 76, name: "apple-touch-icon-76x76.png" },
        { width: 114, height: 114, name: "apple-touch-icon-114x114.png" },
        { width: 120, height: 120, name: "apple-touch-icon-120x120.png" },
        { width: 144, height: 144, name: "apple-touch-icon-144x144.png" },
        { width: 152, height: 152, name: "apple-touch-icon-152x152.png" },
        { width: 180, height: 180, name: "apple-touch-icon-180x180.png" },
        // Android Chrome Icons
        { width: 192, height: 192, name: "android-chrome-192x192.png" },
        { width: 512, height: 512, name: "android-chrome-512x512.png" },
        // Microsoft tiles
        { width: 70, height: 70, name: "mstile-70x70.png" },
        { width: 144, height: 144, name: "mstile-144x144.png" },
        { width: 150, height: 150, name: "mstile-150x150.png" },
        { width: 310, height: 310, name: "mstile-310x310.png" },
        { width: 310, height: 150, name: "mstile-310x150.png" },
      ];

      document.getElementById("generate").onclick = () => {
        const whiteLabelName = document
          .getElementById("whiteLabelName")
          .value.trim();

        if (!whiteLabelName) {
          showMessage("Please enter a white label name", "error");
          return;
        }

        // Remove favicon check
        // Reset UI state
        document.getElementById("download-section").style.display = "none";
        document.getElementById("generate").disabled = true;

        parent.postMessage(
          {
            pluginMessage: {
              type: "generate-theme",
              whiteLabelName,
            },
          },
          "*"
        );
      };

      document.getElementById("download-ts").onclick = () => {
        if (!generatedFiles?.typescript) return;
        downloadFile(
          `${document.getElementById("whiteLabelName").value}.brand.ts`,
          generatedFiles.typescript
        );
      };

      document.getElementById("download-scss-colors").onclick = () => {
        if (!generatedFiles?.scss) return;
        downloadFile(
          `${document.getElementById("whiteLabelName").value}.colors.scss`,
          generatedFiles.scss
        );
      };

      document.getElementById("download-scss-theme").onclick = () => {
        if (!generatedFiles?.scssTheme) return;
        const whiteLabelName = document.getElementById("whiteLabelName").value;
        const lowerCaseWhiteLabelName =
          whiteLabelName.charAt(0).toLowerCase() + whiteLabelName.slice(1);
        downloadFile(
          `${lowerCaseWhiteLabelName}.scss`,
          generatedFiles.scssTheme
        );
      };

      document.getElementById("download-scss-email").onclick = () => {
        if (!generatedFiles?.scssEmail) return;
        const whiteLabelName = document.getElementById("whiteLabelName").value;
        const lowerCaseWhiteLabelName =
          whiteLabelName.charAt(0).toLowerCase() + whiteLabelName.slice(1);
        downloadFile(
          `${lowerCaseWhiteLabelName}-email.scss`,
          generatedFiles.scssEmail
        );
      };

      document.getElementById("download-app-config").onclick = () => {
        if (!generatedFiles?.appConfig) return;
        const whiteLabelName = document.getElementById("whiteLabelName").value;
        const lowerCaseWhiteLabelName =
          whiteLabelName.charAt(0).toLowerCase() + whiteLabelName.slice(1);
        downloadFile(
          `${lowerCaseWhiteLabelName}.config.json`,
          generatedFiles.appConfig
        );
      };

      document.getElementById("download-all-web").onclick = async () => {
        try {
          if (
            !generatedFiles?.typescript ||
            !generatedFiles?.scss ||
            !generatedFiles?.scssTheme ||
            !generatedFiles?.scssEmail ||
            !generatedFiles?.appConfig
          ) {
            showMessage("Error: Missing generated files", "error");
            return;
          }

          const whiteLabelName =
            document.getElementById("whiteLabelName").value;
          const lowerCaseWhiteLabelName =
            whiteLabelName.charAt(0).toLowerCase() + whiteLabelName.slice(1);

          // Create a new ZIP using the browser's JSZip
          const zip = new JSZip();

          // Add files to the zip with correct names
          zip.file(
            `${lowerCaseWhiteLabelName}.brand.ts`,
            generatedFiles.typescript
          );
          zip.file(
            `${lowerCaseWhiteLabelName}.colors.scss`,
            generatedFiles.scss
          );
          zip.file(`${lowerCaseWhiteLabelName}.scss`, generatedFiles.scssTheme);
          zip.file(
            `${lowerCaseWhiteLabelName}-email.scss`,
            generatedFiles.scssEmail
          );
          zip.file(
            `${lowerCaseWhiteLabelName}.config.json`,
            generatedFiles.appConfig
          );

          // Only add favicon files if a favicon was uploaded
          if (favicon && generatedFaviconFiles) {
            // Add all generated favicon files
            for (const [filename, fileData] of Object.entries(
              generatedFaviconFiles
            )) {
              if (fileData.blob) {
                // Binary file (images)
                zip.file(filename, fileData.blob, { binary: true });
              } else if (fileData.content) {
                // Text file (JSON, XML, HTML)
                zip.file(filename, fileData.content);
              }
            }
          } else if (favicon) {
            // Fallback: generate files on the fly if not already generated
            showMessage("Generating favicon files...", "info");
            const faviconFiles = await generateAllFaviconFiles(favicon);
            for (const [filename, fileData] of Object.entries(faviconFiles)) {
              if (fileData.blob) {
                zip.file(filename, fileData.blob, { binary: true });
              } else if (fileData.content) {
                zip.file(filename, fileData.content);
              }
            }
          }

          // Generate and download the zip
          const blob = await zip.generateAsync({ type: "blob" });
          saveAs(blob, `${lowerCaseWhiteLabelName}.zip`);

          showMessage("Files downloaded successfully!", "success");
        } catch (error) {
          console.error("Error creating zip:", error);
          showMessage("Error creating zip file", "error");
        }
      };

      document.getElementById("submit-prs").onclick = async () => {
        const submitButton = document.getElementById("submit-prs");
        const username = document.getElementById("bitbucket-username").value;
        const token = document.getElementById("bitbucket-token").value;

        if (!username || !token) {
          showMessage("Please enter both username and app password", "error");
          return;
        }

        if (
          !generatedFiles?.typescript ||
          !generatedFiles?.scss ||
          !generatedFiles?.scssTheme ||
          !generatedFiles?.scssEmail ||
          !generatedFiles?.appConfig
        ) {
          showMessage("Error: Missing generated files", "error");
          return;
        }

        // Disable button and show loading state
        submitButton.disabled = true;
        submitButton.textContent = "Creating Pull Request...";

        const whiteLabelName = document.getElementById("whiteLabelName").value;

        try {
          // Initialize with text files
          const files = {
            typescript: generatedFiles.typescript,
            scss: generatedFiles.scss,
            scssTheme: generatedFiles.scssTheme,
            scssEmail: generatedFiles.scssEmail,
          };

          // Only add favicon files if a favicon was uploaded
          if (favicon) {
            // Generate favicon files if not already generated
            if (!generatedFaviconFiles) {
              showMessage("Generating favicon files...", "info");
              generatedFaviconFiles = await generateAllFaviconFiles(favicon);
            }

            // Add all generated favicon files to the files object
            for (const [filename, fileData] of Object.entries(
              generatedFaviconFiles
            )) {
              if (fileData.dataUri) {
                // Image files - use data URI
                files[filename] = fileData.dataUri;
              } else if (fileData.content) {
                // Text files - use content directly
                files[filename] = fileData.content;
              }
            }
          }

          parent.postMessage(
            {
              pluginMessage: {
                type: "create-prs",
                whiteLabelName,
                credentials: { username, token },
                files,
              },
            },
            "*"
          );
        } catch (error) {
          console.error("Error preparing files:", error);
          showMessage("Error preparing files for pull request", "error");
          submitButton.disabled = false;
          submitButton.textContent = "Create Pull Requests";
        }
      };

      function downloadFile(filename, content) {
        const element = document.createElement("a");
        element.setAttribute(
          "href",
          "data:text/plain;charset=utf-8," + encodeURIComponent(content)
        );
        element.setAttribute("download", filename);
        element.style.display = "none";
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      }

      function showMessage(message, type) {
        const messageEl = document.getElementById("message");
        messageEl.textContent = message;
        messageEl.className = type;
      }

      onmessage = (event) => {
        const msg = event.data.pluginMessage;
        const submitButton = document.getElementById("submit-prs");
        const downloadFaviconsButton =
          document.getElementById("download-favicons");

        if (msg.type === "variable-log") {
          console.log("ðŸ“‹ Variable Log:", msg.message);
          if (msg.variable) {
            console.log("   Variable Details:", msg.variable);
          }
          return;
        }

        if (msg.type === "variable-log-complete") {
          console.log("âœ… Variable Logging Complete");
          console.log("ðŸ“Š Summary:", msg.summary);
          console.log("ðŸ“¦ All Collections:", msg.collections);

          // Log detailed variable information
          msg.collections.forEach((collection, idx) => {
            console.log(`\nðŸ“ Collection ${idx + 1}: "${collection.name}"`);
            console.log(`   Modes: ${collection.modes.join(", ")}`);
            console.log(`   Variables: ${collection.variableCount}`);
            collection.variables.forEach((variable, varIdx) => {
              console.log(`\n   ðŸŽ¨ Variable ${varIdx + 1}: "${variable.name}"`);
              console.log(`      Type: ${variable.type}`);
              console.log(`      Values by Mode:`);
              Object.keys(variable.values).forEach((modeName) => {
                const value = variable.values[modeName];
                if (value.hex) {
                  console.log(
                    `         ${modeName}: ${value.hex} (RGB: ${value.rgb.r}, ${value.rgb.g}, ${value.rgb.b})`
                  );
                } else {
                  console.log(`         ${modeName}: ${JSON.stringify(value)}`);
                }
              });
            });
          });
          return;
        }

        if (msg.type === "pr-progress") {
          showMessage(msg.message, "info");
          if (msg.url) {
            // Create PR link if URL is provided
            const messageEl = document.getElementById("message");
            messageEl.innerHTML = `${msg.message} <a href="${msg.url}" target="_blank">View PR</a>`;
          }
          return;
        }

        // Reset submit button state
        if (msg.type !== "pr-progress") {
          submitButton.disabled = false;
          submitButton.textContent = "Create Pull Requests";
        }

        if (msg.type === "error") {
          showMessage(msg.message, "error");
          return;
        }

        if (msg.type === "prs-created") {
          showMessage(msg.message, "success");
        }

        if (msg.type === "theme-generated") {
          generatedFiles = msg.data;
          document.getElementById("download-section").style.display = "block";
          document.getElementById("generate").disabled = false;

          // Update favicon button state
          downloadFaviconsButton.disabled = !favicon;
          if (!favicon) {
            downloadFaviconsButton.title = "Please upload a favicon first";
          } else {
            downloadFaviconsButton.title = "";
          }
        }
      };

      // Favicon related code
      document.getElementById("download-favicons").onclick = async () => {
        if (!favicon) {
          showMessage("Please upload a favicon first", "error");
          return;
        }
        const whiteLabelName = document.getElementById("whiteLabelName").value;
        await downloadResizedImagesAsZip({
          favicon,
          sizes: faviconSizes,
          whiteLabelName,
        });
      };
      // Server URL - change this to your server URL or use localhost for development
      const FAVICON_SERVER_URL = "http://localhost:3001";

      document.getElementById("favicon").onchange =
        async function handleFaviconSelect(event) {
          const file = event.target.files?.[0];
          if (!file) return;

          // Verify it's an image file
          if (!file.type.startsWith("image/")) {
            showMessage("Please select an image file", "error");
            return;
          }

          // Store the file for later use
          const blobUrl = URL.createObjectURL(file);
          favicon = blobUrl;

          // Generate favicon files using the server
          showMessage("Generating favicon files...", "info");

          try {
            const formData = new FormData();
            formData.append("image", file);
            formData.append(
              "siteName",
              document.getElementById("whiteLabelName").value || "Site"
            );

            const response = await fetch(
              `${FAVICON_SERVER_URL}/api/generate-favicons`,
              {
                method: "POST",
                body: formData,
              }
            );

            if (!response.ok) {
              const errorData = await response.json();
              throw new Error(
                errorData.message || "Failed to generate favicons"
              );
            }

            const result = await response.json();

            if (result.success && result.files) {
              // Convert server response to our format
              generatedFaviconFiles = {};
              for (const [filename, fileData] of Object.entries(result.files)) {
                if (fileData.encoding === "base64") {
                  // Convert base64 to blob
                  const byteCharacters = atob(fileData.content);
                  const byteNumbers = new Array(byteCharacters.length);
                  for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                  }
                  const byteArray = new Uint8Array(byteNumbers);
                  const blob = new Blob([byteArray], {
                    type: fileData.mimeType,
                  });
                  const dataUri = `data:${fileData.mimeType};base64,${fileData.content}`;

                  generatedFaviconFiles[filename] = {
                    blob: blob,
                    dataUri: dataUri,
                    mimeType: fileData.mimeType,
                  };
                } else {
                  // Text content
                  generatedFaviconFiles[filename] = {
                    content: fileData.content,
                    mimeType: fileData.mimeType,
                  };
                }
              }

              // Store HTML markup if provided
              if (result.html) {
                generatedFaviconFiles["favicon-markup.html"] = {
                  content: result.html,
                  mimeType: "text/html",
                };
              }

              showMessage("Favicon files ready for download!", "success");

              // Update button state
              const downloadFaviconsButton =
                document.getElementById("download-favicons");
              if (downloadFaviconsButton) {
                downloadFaviconsButton.disabled = false;
                downloadFaviconsButton.title = "";
              }
            } else {
              throw new Error("Invalid response from server");
            }
          } catch (error) {
            console.error("Error generating favicon files:", error);
            showMessage(
              `Error generating favicon files: ${error.message}. Make sure the server is running (npm run server)`,
              "error"
            );
          }
        };

      /**
       * @description Resize an image to the target width and height using "safe zone" approach.
       * This ensures the entire icon is visible with padding to prevent clipping from masks/rounded corners.
       * Uses 80% safe zone (like RealFaviconGenerator) to leave 10% padding on all sides.
       */
      async function resizeImage({ favicon, targetWidth, targetHeight }) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.src = favicon;

          img.onload = () => {
            // Safe zone: use 80% of the canvas to leave 10% padding on all sides
            // This prevents clipping when platforms apply masks or rounded corners
            const safeZonePadding = 0.1; // 10% padding on each side
            const safeZoneWidth = targetWidth * (1 - safeZonePadding * 2);
            const safeZoneHeight = targetHeight * (1 - safeZonePadding * 2);

            const imgAspectRatio = img.width / img.height;
            const safeZoneAspectRatio = safeZoneWidth / safeZoneHeight;

            // Calculate the scale to fit the entire image within the safe zone (contain mode)
            let scale;
            if (imgAspectRatio > safeZoneAspectRatio) {
              // Image is wider - scale based on safe zone height
              scale = safeZoneHeight / img.height;
            } else {
              // Image is taller - scale based on safe zone width
              scale = safeZoneWidth / img.width;
            }

            // Calculate the actual dimensions after scaling
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;

            // Calculate centering offset within the safe zone
            // The safe zone is already centered, so we center the image within it
            const safeZoneOffsetX = targetWidth * safeZonePadding;
            const safeZoneOffsetY = targetHeight * safeZonePadding;
            const offsetX = safeZoneOffsetX + (safeZoneWidth - scaledWidth) / 2;
            const offsetY =
              safeZoneOffsetY + (safeZoneHeight - scaledHeight) / 2;

            const canvas = document.createElement("canvas");
            canvas.width = targetWidth;
            canvas.height = targetHeight;

            const ctx = canvas.getContext("2d");

            // Fill with transparent background
            ctx.clearRect(0, 0, targetWidth, targetHeight);

            // Draw the image centered within the safe zone
            ctx.drawImage(
              img,
              0,
              0,
              img.width,
              img.height,
              offsetX,
              offsetY,
              scaledWidth,
              scaledHeight
            );

            canvas.toBlob(resolve, "image/png");
          };
          img.onerror = reject;
        });
      }
      /**
       * @description Generate all favicon files (comprehensive like RealFaviconGenerator)
       */
      async function generateAllFaviconFiles(faviconUrl) {
        const files = {};

        // Generate all PNG sizes
        for (const size of faviconSizes) {
          const blob = await resizeImage({
            favicon: faviconUrl,
            targetWidth: size.width,
            targetHeight: size.height,
          });

          // Convert blob to base64 data URI for storage
          const dataUri = await blobToDataUri(blob);
          files[size.name] = {
            blob: blob,
            dataUri: dataUri,
            mimeType: "image/png",
          };
        }

        // Generate favicon.ico (64x64)
        const icoBlob = await resizeImage({
          favicon: faviconUrl,
          targetWidth: 64,
          targetHeight: 64,
        });
        const icoDataUri = await blobToDataUri(icoBlob);
        files["favicon.ico"] = {
          blob: icoBlob,
          dataUri: icoDataUri,
          mimeType: "image/x-icon",
        };

        // Generate site.webmanifest
        const manifest = generateWebAppManifest();
        files["site.webmanifest"] = {
          content: JSON.stringify(manifest, null, 2),
          mimeType: "application/manifest+json",
        };

        // Generate browserconfig.xml (for Windows tiles)
        const browserConfig = generateBrowserConfig();
        files["browserconfig.xml"] = {
          content: browserConfig,
          mimeType: "application/xml",
        };

        // Generate HTML markup
        const htmlMarkup = generateFaviconHtml();
        files["favicon-markup.html"] = {
          content: htmlMarkup,
          mimeType: "text/html",
        };

        return files;
      }

      /**
       * @description Convert blob to data URI
       */
      function blobToDataUri(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }

      /**
       * @description Generate a web app manifest
       */
      function generateWebAppManifest() {
        const whiteLabelName = document.getElementById("whiteLabelName").value;
        return {
          name: whiteLabelName,
          short_name: whiteLabelName,
          icons: [
            {
              src: "/android-chrome-192x192.png",
              sizes: "192x192",
              type: "image/png",
              purpose: "any maskable",
            },
            {
              src: "/android-chrome-512x512.png",
              sizes: "512x512",
              type: "image/png",
              purpose: "any maskable",
            },
          ],
          theme_color: "#ffffff",
          background_color: "#ffffff",
          display: "standalone",
        };
      }

      /**
       * @description Generate browserconfig.xml for Windows tiles
       */
      function generateBrowserConfig() {
        return `<?xml version="1.0" encoding="utf-8"?>
<browserconfig>
    <msapplication>
        <tile>
            <square70x70logo src="/mstile-70x70.png"/>
            <square150x150logo src="/mstile-150x150.png"/>
            <square310x310logo src="/mstile-310x310.png"/>
            <wide310x150logo src="/mstile-310x150.png"/>
            <TileColor>#ffffff</TileColor>
        </tile>
    </msapplication>
</browserconfig>`;
      }

      /**
       * @description Generate HTML markup for favicons
       */
      function generateFaviconHtml() {
        const whiteLabelName = document.getElementById("whiteLabelName").value;
        return `<!-- Favicon HTML Markup -->
<!-- Standard favicons -->
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="shortcut icon" href="/favicon.ico">

<!-- Apple Touch Icons -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png">
<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon.png">

<!-- Android Chrome -->
<link rel="manifest" href="/site.webmanifest">

<!-- Microsoft Tiles -->
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/mstile-144x144.png">
<meta name="msapplication-config" content="/browserconfig.xml">`;
      }

      /**
       * @description Download the resized images as a zip file (comprehensive favicon package).
       */
      async function downloadResizedImagesAsZip({
        favicon,
        sizes,
        whiteLabelName,
      }) {
        if (!generatedFaviconFiles) {
          // Generate files if not already generated
          showMessage("Generating favicon files...", "info");
          generatedFaviconFiles = await generateAllFaviconFiles(favicon);
        }

        const zip = new JSZip();

        // Add all generated files to zip
        for (const [filename, fileData] of Object.entries(
          generatedFaviconFiles
        )) {
          if (fileData.blob) {
            // Binary file (images)
            zip.file(filename, fileData.blob, { binary: true });
          } else if (fileData.content) {
            // Text file (JSON, XML, HTML)
            zip.file(filename, fileData.content);
          }
        }

        const content = await zip.generateAsync({ type: "blob" });
        saveAs(content, `favicons-${whiteLabelName}.zip`);
        showMessage("Favicon files downloaded successfully!", "success");
      }
    </script>
  </body>
</html>
